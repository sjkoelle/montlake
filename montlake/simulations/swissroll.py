# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/simulations.swissroll.ipynb (unless otherwise specified).

__all__ = ['get_swiss_roll_data', 'get_dx_g_full', 'get_swiss_roll_gradients', 'get_swiss_roll_gradients_noy',
           'get_swiss_roll_gradients_noy_norotate']

# Cell
import numpy as np
from scipy.stats import special_ortho_group

def get_swiss_roll_data(n = 10000, theta =np.pi / 4,xvar = 0., rotate = True, b = 49):

    ts = .75 * np.pi * (1 + 2 * np.random.uniform(low=0.0, high=1.0, size=n)) + 15
    x = ts * np.cos(ts)
    y = 101 * np.random.uniform(low=0.0, high=1.0, size=n)
    #self.ys = y
    z = ts * np.sin(ts)
    #self.ts = ts
    X = np.vstack((x, y, z))
    X = X.T
    unrotated_data = np.zeros((n, b))
    unrotated_data[:, :3] = X


    if rotate:
        rotator = special_ortho_group.rvs(b)
        data = np.matmul(unrotated_data, rotator)
    else:
        rotator = np.identity(b)
        data = unrotated_data

    if xvar != 0.:
        data += np.random.multivariate_normal(np.zeros(b), np.identity(b) * xvar, n)

    return(data,rotator, ts, y)



# Cell
def get_dx_g_full(self, data):
    d = self.d
    p = self.p
    # n = data.shape[0]
    n = len(self.selected_points)
    ts = self.ts[self.selected_points]
    grads = np.asarray([get_grad(t) for t in ts])
    rotator = self.rotator
    # grads2 = rotator(grads, theta)
    fullgrads = np.zeros((n, d, p))
    for i in range(n):
        fullgrads[i, :, 0:2] = np.matmul(rotator.transpose(), grads[i])
        fullgrads[i, :, 2:] = np.identity(49)
    output = np.swapaxes(fullgrads, 1, 2)
    return (output)

def get_swiss_roll_gradients(t,rotator,b):

    output = np.zeros((b,b+2))
    output[0,0] = ((np.cos(t) - t*np.sin(t)) / (np.sin(t) + t*np.cos(t)))
    output[2,0] = 1.
    output[1,1] = 1.
    output[:,:2] = np.einsum('b p, p -> b p', output[:,:2] , np.linalg.norm(output[:,:2], axis = 0)**(-1))
    output = np.einsum('b p, b c -> c p', output, rotator)
    output[:,2:] = np.identity(b)

    return(output)

def get_swiss_roll_gradients_noy(t,rotator,b):

    output = np.zeros((b,b+1))
    output[0,0] = ((np.cos(t) - t*np.sin(t)) / (np.sin(t) + t*np.cos(t)))
    output[2,0] = 1.
    output[:,:1] = np.einsum('b p, p -> b p', output[:,:1] , np.linalg.norm(output[:,:1], axis = 0)**(-1))
    output = np.einsum('b p, b c -> c p', output, rotator)
    output[:,1:] = np.identity(b)
    return(output)

def get_swiss_roll_gradients_noy_norotate(t,b):

    output = np.zeros((b,b))
    output[0,0] = ((np.cos(t) - t*np.sin(t)) / (np.sin(t) + t*np.cos(t)))
    output[2,0] = 1.
    output[:,:1] = np.einsum('b p, p -> b p', output[:,:1] , np.linalg.norm(output[:,:1], axis = 0)**(-1))
    output[0,1] = 1
    output[2:,2:] = np.identity(b-2)
    return(output)